from typing import overload

import numpy as np
from scipy.sparse import csr_array
from scipy.sparse.linalg import spsolve

from .mesh import MeshStructure
from .cell import CellVariable
from .boundary import BoundaryConditions


@overload
def solvePDE(m: MeshStructure, M:csr_array, RHS: np.ndarray,
             externalsolver = None) -> CellVariable:
    ...
    
@overload
def solvePDE(phi: CellVariable, bcterm: tuple, eqnterms: list, 
              externalsolver = None) -> CellVariable:
    ...
    
def solvePDE(p1, p2 , p3, externalsolver = None):
    """
    Solve the PDE using the finite volume method.
    
    
    Variant 1
    =========
    
    Uses the M matrix and RHS right-hand side vector directly.
    
    Returns a new CellVariable without changing the input ('old') CellVariable.
    
    Parameters
    ----------
    m: MeshStructure
        Mesh structure
    M: csr_array
        Matrix of the linear system
    RHS: np.ndarray
        Right hand side of the linear system
    externalsolver: function (optional)
        If provided, use an external sparse solver via a function call
        having the same interface as the default solver
        scipy.sparse.linalg.spsolve.
    
    Returns
    -------
    phi: CellVariable
        Solution of the PDE
        
        
    Variant 2
    =========

    Constructs the matrix equation based on provided terms (each term being
    the output of a call to the appropriate xxxTerm() function) 
    
    The provided CellVariable is updated with the solution values.

    Parameters
    ----------
    phi : CellVariable
        Solution variable subject to the boundary conditions represented by
        bcterm.
    bcterm : tuple(csr_array, np.ndarray)
        Matrix equation terms (M, RHS) representing the boundary conditions,
        i.e. the result from a call to boundaryConditionsTerm
    eqnterms : list
        List of matrix equation terms generated by the xxxTerm functions.
        The elements of the list can either be a tuple (M, RHS), a simple 
        csr_array matrix (M) or a 1D np.ndarray (RHS). These will be added
        up to create both the M and RHS of the matrix equation to be solved.
    externalsolver : function, optional
        If specified, use an external sparse solver via a function call
        having the same interface as the default solver
        `scipy.sparse.linalg.spsolve`. If not specified, this default
        solver will be used.

    Raises
    ------
    TypeError
        If any of the provided terms is not conform to expectations.

    Returns
    -------
    CellVariable
        The updated CellVariable.

    
    """
    # Dispatcher
    
    # add more explicit type checking for user-friendliness?
    if isinstance(p1, CellVariable):
        return _solvePDE2(p1, p2, p3, externalsolver = externalsolver)    
    elif isinstance(p1, MeshStructure):
        return _solvePDE1(p1, p2, p3, externalsolver = externalsolver)    
    else:
        raise TypeError('Unknown parameter type')           


def _solvePDE1(m: MeshStructure, M:csr_array, RHS: np.ndarray,
             externalsolver = None) -> CellVariable:
    if externalsolver is None:
        solver = spsolve
    else:
        solver = externalsolver
    phi = solver(M, RHS)
    return CellVariable(m, np.reshape(phi, m.dims+2))


def _solvePDE2(phi: CellVariable, bcterm: tuple, eqnterms: list, 
              externalsolver = None) -> CellVariable:
    if externalsolver is None:
        solver = spsolve
    else:
        solver = externalsolver
    
    Mbc, RHSbc = bcterm
    M = Mbc
    RHS = RHSbc
    for term in eqnterms:
        if isinstance(term, tuple):
            Mterm, RHSterm = term
            if (Mterm.ndim != 2) or (RHSterm.ndim != 1):
                raise TypeError('Unknown term')
            M += Mterm
            RHS += RHSterm
        elif term.ndim == 1:
            RHS += term
        elif term.ndim == 2:
            M += term
        else:
            raise TypeError('Unknown term')
            
    phi_new_values = solver(M, RHS)
    phi.value[:] = phi_new_values
    return phi



def solveExplicitPDE(phi_old: CellVariable, dt: float, RHS: np.ndarray, 
                     BC: BoundaryConditions) -> CellVariable:
    """
    Solve the PDE using the finite volume method.

    Parameters
    ----------
    phi_old: CellVariable
        Solution of the previous time step
    dt: float
        Time step
    RHS: np.ndarray
        Right hand side of the linear system
    BC: BoundaryConditions
        Boundary conditions
    
    Returns
    -------
    phi: CellVariable
        Solution of the PDE
    """
    

    x = phi_old.value + dt*RHS.reshape(phi_old.value.shape)
    phi= CellVariable(phi_old.domain, 0.0)
    phi.value = x
    phi.update_bc_cells(BC)
    return phi
